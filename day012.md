# 2025.12.31
今天复习了自控，感觉东西不多：状态图、时域、劳斯判据、根轨迹、奈奎斯特判据、非线性、离散系统，希望能复习完吧。

## 力扣每日一题:
  102.二叉树的层序遍历
  [https://leetcode.cn/problems/binary-tree-level-order-traversal?envType=study-plan-v2&envId=top-100-liked]

### 思路：
通过数组、列表实现bfs就行
- 数组实现：通过数组nxt储存下一层的节点，cur储存这一层的节点，遍历cur的所有节点，把val加入vals里，再把节点的left和right加入nxt里，遍历完后，把vals加入ans，cur变成nxt，开始下层遍历。
  ```python
  class Solution(object):
    def levelOrder(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: List[List[int]]
        """
        if root is None:
            return []
        ans = []
        cur = [root]
        while cur:
            nxt = []
            vals = []
            for node in cur:
                vals.append(node.val)
                if node.left:
                    nxt.append(node.left)
                if node.right:
                    nxt.append(node.right)
            cur = nxt
            ans.append(vals)
        return ans
- 列表实现：创建初始列表，不断把下层压入列表，且每次遍历完一层后，此刻列表里所有的元素一定是下一层所有的元素，因此需要规定下一次遍历时的长度。
  ```python
  class Solution(object):
    def levelOrder(self, root):
        """
        :type root: Optional[TreeNode]
        :rtype: List[List[int]]
        """
        if root is None:
            return []
        ans = []
        q = deque([root])
        while q:
            vals = []
            for i in range(len(q)):
                node = q.popleft()
                vals.append(node.val)
                if node.left: q.append(node.left)
                if node.right: q.append(node.right)
            ans.append(vals)
        return ans    


## 每日碎碎念
* 还是抢不到票
* 我感觉应该复习得完？
* 叶瞬光可爱捏。
* 写的时候已经是新年了，新年快乐！
